{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pointer Brakes","text":"<p>Pointer Brakes is a library for simulating mouse pointer motion.  The pointer will behave like it is a little car with brakes.  If you push it, it moves.  If you let go, it keeps moving but slowly comes to a stop as it applies the brakes.</p>"},{"location":"about/","title":"About","text":""},{"location":"about/#why-did-you-make-this","title":"Why did you make this?","text":"<p>The short answer is there are no Python libraries for simulating the mouse cursor behavior of a trackball mouse.</p> <p>The long answer is I have wrist injuries which require I immobilize my wrists when working.  This means I am restricted to ergo keyboards and thumb trackball mice.  The keyboard is great; however the trackball mice stinks. I'm absolutely tired of the inconsistency in movement and constant cleaning.</p> <p>Wouldn't it be nice if I could just purchase a thumb trackpad mouse which acts like a thumb trackball mouse?  Well, they don't exist so I'll have to make one myself.  To complete this task I've chosen to go the CircuitPython route.  Thus, here we are creating a library to handle the pointer motion simulation</p>"},{"location":"reference/","title":"API reference","text":"<p>NOTE  The docstrings were generated by OpenAI ChatGPT then edited by me</p>"},{"location":"reference/#pointer_brakes.PointerMotionSim","title":"<code>pointer_brakes.PointerMotionSim</code>","text":"<p>A simulation of pointer motion, including touch-driven and free rolling motion.</p> <p>Attributes:</p> Name Type Description <code>a_braking</code> <code>float</code> <p>The magnitude of acceleration caused by pointer brakes.</p> Example <pre><code>sim_instance = PointerMotionSim(2.0)\n</code></pre> Source code in <code>src/pointer_brakes/_sim.py</code> <pre><code>class PointerMotionSim:\n    \"\"\"A simulation of pointer motion, including touch-driven and free rolling motion.\n\n    Attributes:\n        a_braking (float): The magnitude of acceleration caused by pointer brakes.\n\n    Example:\n        ```python\n        sim_instance = PointerMotionSim(2.0)\n        ```\n    \"\"\"\n\n    # magnitude of acceleration due to braking (using during pointer rolling motion)\n    a_braking: float\n\n    # simulation state\n    _state: State\n    _last_state: State\n\n    # initial velocity (using during pointer rolling motion)\n    _v0: Vec2D | None\n\n    def __init__(self, a_braking: float) -&gt; None:\n        self.a_braking = a_braking\n        self._state = State()\n        self._last_state = State()\n        self._v0 = None\n\n    def tick(self, timestamp: int, touch_pos: tuple[int, int] | None = None) -&gt; None:\n        \"\"\"Update the state of the PointerMotionSim\n\n        This method updates the simulation state of the PointerMotionSim instance. When\n        touch position is provided the pointer will be moved.  When the touch position,\n        inevitably, goes idle then the simulation will continue moving until the\n        pointer comes to rest due to braking.\n\n        Args:\n            timestamp (int): The timestamp at which the update occurs.\n            touch_pos (tuple[int, int] | None): The current touch position as a tuple\n                (x, y), or None if touch is idle.\n\n        Example usage:\n        ```python\n        a_brakes = 1\n        sim_instance = PointerMotionSim(a_brakes)\n        current_timestamp = time.monotonic_ns()\n        current_touch_pos = (50, 50)\n        sim_instance.tick(current_timestamp, current_touch_pos)\n        ```\n        \"\"\"\n        # if touch is idle and motion is stopped then do nothing\n        if not touch_pos and not self.velocity:\n            # ensure state is cleared to reflect idleness\n            if self._state.timestamp:\n                self.stop_motion()\n            return\n\n        # if touch is idle then update initial velocity\n        if not touch_pos:\n            self._v0 = self.velocity\n\n        # reject zero-time ticks\n        if self._state.timestamp == timestamp:\n            return\n\n        # update simulation state\n        self._last_state = self._state.copy()\n        self._state = EMPTY_STATE.copy()\n        self._state.timestamp = timestamp\n\n        # update touch data if present\n        self._state.touch_pos = touch_pos if touch_pos else None\n\n    @property\n    def delta_time(self) -&gt; int:\n        \"\"\"The time difference between the current state and the last state.\n\n        This property calculates the delta time, representing the time elapsed between\n        the current state and the last state in the simulation. It ensures that both\n        timestamps are available; otherwise, it raises a DeltaTimeInvalidError.\n\n        Returns:\n            The time difference (delta time) between the current and last state\n                timestamps.\n\n        Raises:\n            DeltaTimeInvalidError: If either the current state timestamp or the last state\n                timestamp is not set.\n\n        Example:\n            ```python\n            a_brakes = 1\n            sim_instance = PointerMotionSim(a_brakes)\n            sim_instance.tick(time.monotonic_ns(), (50, 50))\n            sim_instance.tick(time.monotonic_ns(), (60, -30))\n            time_difference = sim_instance.delta_time\n            ```\n        \"\"\"\n        if not self._state.timestamp or not self._last_state.timestamp:\n            raise DeltaTimeInvalidError(self._last_state.timestamp, self._state.timestamp)\n\n        return self._state.timestamp - self._last_state.timestamp\n\n    @property\n    def velocity(self) -&gt; Vec2D | None:\n        \"\"\"The current pointer velocity.\n\n        This property handles various scenarios to determine the current velocity of\n        the simulation. If there's touch-driven motion, it calculates velocity based on\n        the change in position over time. For pointer rolling motion, it uses standard\n        accelerated motion calculations where acceleration direction is opposite to\n        velocity with magnitude of acceleration due to braking.\n\n        Returns:\n            The calculated velocity as a 2D Vector instance or None if\n                motion is stopped.\n\n        Raises:\n            DeltaPositionInvalidError: The change in is not valid during touch-driven\n                motion.\n            VelocityInvalidError: The p method encounters an unexpected condition.\n\n        Example:\n            ```python\n            a_brakes = 1\n            sim_instance = PointerMotionSim(a_brakes)\n            sim_instance.tick(time.monotonic_ns(), (30, 12))\n            sim_instance.tick(time.monotonic_ns(), (104, 23))\n            current_velocity = sim_instance.velocity\n            ```\n        \"\"\"\n        # if we have blank timestamps then motion is stopped\n        if not self._last_state.timestamp and not self._state.timestamp:\n            return None\n\n        # handle transition from idle to touch motion\n        if self._state.touch_pos and not self._last_state.touch_pos:\n            return None\n\n        # handle touch-driven motion\n        if self._last_state.touch_pos and self._state.touch_pos:\n            if not self.delta_position:\n                raise DeltaPositionInvalidError(self._last_state.touch_pos, self._state.touch_pos)\n\n            return self.delta_position / self.delta_time\n\n        # handle pointer rolling motion\n        if self._v0 and not self._state.touch_pos:\n            # use standard accelerated motion calculation\n            v_magnitude = self._v0.len() - self.a_braking * self.delta_time\n\n            # if braking would reduce the velocity to 0 or less then stop motion\n            if v_magnitude &lt;= 0:\n                self.stop_motion()\n                return None\n\n            return self._v0.dir() * v_magnitude\n\n        raise VelocityInvalidError\n\n    def stop_motion(self) -&gt; None:\n        \"\"\"Stop all motion in the simulation\n\n        This method resets the simulation state and initial velocity to indicate that\n        all motion has stopped.\n\n        Example usage:\n            ```python\n            a_brakes = 1\n            sim_instance = PointerMotionSim(a_brakes)\n            sim_instance.tick(time.monotonic_ns(), (15, -75))\n            sim_instance.tick(time.monotonic_ns(), (-83, 11))\n            sim_instance.stop_motion()\n            ```\n        \"\"\"\n        # reset the state to empty to indicate all motion is stopped\n        self._last_state = EMPTY_STATE.copy()\n        self._state = EMPTY_STATE.copy()\n        self._v0 = None\n\n    @property\n    def delta_position(self) -&gt; Vec2D | None:\n        \"\"\"The change in position between the last two state ticks.\n\n        For touch-driven motion, it simply calculates the change in position between\n        the current and last touch positions. For pointer rolling motion, it uses\n        standard accelerated motion calculations where acceleration direction is\n        opposite to velocity with magnitude of acceleration due to braking.\n\n        Returns:\n            The 2D vector representing the change in position from last\n                state tick to the current state tick.\n\n        Raises:\n            DeltaPositionInvalidError: If the delta position cannot be determined.\n\n        Example:\n            ```python\n            a_brakes = 1\n            sim_instance = PointerMotionSim(a_brakes)\n            sim_instance.tick(time.monotonic_ns(), (-52, -5))\n            sim_instance.tick(time.monotonic_ns(), (21, -92))\n            change_in_position = sim_instance.delta_position\n            ```\n        \"\"\"\n        # if theres no touch data and no velocity we're not moving\n        if (not self._state.touch_pos or not self._last_state.touch_pos) and not self.velocity:\n            return None\n\n        # handle touch-driven motion\n        if self._state.touch_pos and self._last_state.touch_pos:\n            return Vec2D(\n                self._state.touch_pos[0] - self._last_state.touch_pos[0],\n                self._state.touch_pos[1] - self._last_state.touch_pos[1],\n            )\n\n        # handle pointer rolling motion; use standard accelerated motion calculation\n        if not self._v0:\n            raise DeltaPositionInvalidError\n\n        delta_pos_mag = self._v0.len() * self.delta_time - self.a_braking / 2 * self.delta_time**2\n        return self._v0.dir() * delta_pos_mag\n</code></pre>"},{"location":"reference/#pointer_brakes.PointerMotionSim.delta_position","title":"<code>delta_position: Vec2D | None</code>  <code>property</code>","text":"<p>The change in position between the last two state ticks.</p> <p>For touch-driven motion, it simply calculates the change in position between the current and last touch positions. For pointer rolling motion, it uses standard accelerated motion calculations where acceleration direction is opposite to velocity with magnitude of acceleration due to braking.</p> <p>Returns:</p> Type Description <code>Vec2D | None</code> <p>The 2D vector representing the change in position from last state tick to the current state tick.</p> <p>Raises:</p> Type Description <code>DeltaPositionInvalidError</code> <p>If the delta position cannot be determined.</p> Example <pre><code>a_brakes = 1\nsim_instance = PointerMotionSim(a_brakes)\nsim_instance.tick(time.monotonic_ns(), (-52, -5))\nsim_instance.tick(time.monotonic_ns(), (21, -92))\nchange_in_position = sim_instance.delta_position\n</code></pre>"},{"location":"reference/#pointer_brakes.PointerMotionSim.delta_time","title":"<code>delta_time: int</code>  <code>property</code>","text":"<p>The time difference between the current state and the last state.</p> <p>This property calculates the delta time, representing the time elapsed between the current state and the last state in the simulation. It ensures that both timestamps are available; otherwise, it raises a DeltaTimeInvalidError.</p> <p>Returns:</p> Type Description <code>int</code> <p>The time difference (delta time) between the current and last state timestamps.</p> <p>Raises:</p> Type Description <code>DeltaTimeInvalidError</code> <p>If either the current state timestamp or the last state timestamp is not set.</p> Example <pre><code>a_brakes = 1\nsim_instance = PointerMotionSim(a_brakes)\nsim_instance.tick(time.monotonic_ns(), (50, 50))\nsim_instance.tick(time.monotonic_ns(), (60, -30))\ntime_difference = sim_instance.delta_time\n</code></pre>"},{"location":"reference/#pointer_brakes.PointerMotionSim.velocity","title":"<code>velocity: Vec2D | None</code>  <code>property</code>","text":"<p>The current pointer velocity.</p> <p>This property handles various scenarios to determine the current velocity of the simulation. If there's touch-driven motion, it calculates velocity based on the change in position over time. For pointer rolling motion, it uses standard accelerated motion calculations where acceleration direction is opposite to velocity with magnitude of acceleration due to braking.</p> <p>Returns:</p> Type Description <code>Vec2D | None</code> <p>The calculated velocity as a 2D Vector instance or None if motion is stopped.</p> <p>Raises:</p> Type Description <code>DeltaPositionInvalidError</code> <p>The change in is not valid during touch-driven motion.</p> <code>VelocityInvalidError</code> <p>The p method encounters an unexpected condition.</p> Example <pre><code>a_brakes = 1\nsim_instance = PointerMotionSim(a_brakes)\nsim_instance.tick(time.monotonic_ns(), (30, 12))\nsim_instance.tick(time.monotonic_ns(), (104, 23))\ncurrent_velocity = sim_instance.velocity\n</code></pre>"},{"location":"reference/#pointer_brakes.PointerMotionSim.stop_motion","title":"<code>stop_motion()</code>","text":"<p>Stop all motion in the simulation</p> <p>This method resets the simulation state and initial velocity to indicate that all motion has stopped.</p> Example usage <pre><code>a_brakes = 1\nsim_instance = PointerMotionSim(a_brakes)\nsim_instance.tick(time.monotonic_ns(), (15, -75))\nsim_instance.tick(time.monotonic_ns(), (-83, 11))\nsim_instance.stop_motion()\n</code></pre> Source code in <code>src/pointer_brakes/_sim.py</code> <pre><code>def stop_motion(self) -&gt; None:\n    \"\"\"Stop all motion in the simulation\n\n    This method resets the simulation state and initial velocity to indicate that\n    all motion has stopped.\n\n    Example usage:\n        ```python\n        a_brakes = 1\n        sim_instance = PointerMotionSim(a_brakes)\n        sim_instance.tick(time.monotonic_ns(), (15, -75))\n        sim_instance.tick(time.monotonic_ns(), (-83, 11))\n        sim_instance.stop_motion()\n        ```\n    \"\"\"\n    # reset the state to empty to indicate all motion is stopped\n    self._last_state = EMPTY_STATE.copy()\n    self._state = EMPTY_STATE.copy()\n    self._v0 = None\n</code></pre>"},{"location":"reference/#pointer_brakes.PointerMotionSim.tick","title":"<code>tick(timestamp, touch_pos=None)</code>","text":"<p>Update the state of the PointerMotionSim</p> <p>This method updates the simulation state of the PointerMotionSim instance. When touch position is provided the pointer will be moved.  When the touch position, inevitably, goes idle then the simulation will continue moving until the pointer comes to rest due to braking.</p> <p>Parameters:</p> Name Type Description Default <code>timestamp</code> <code>int</code> <p>The timestamp at which the update occurs.</p> required <code>touch_pos</code> <code>tuple[int, int] | None</code> <p>The current touch position as a tuple (x, y), or None if touch is idle.</p> <code>None</code> <p>Example usage:</p> <pre><code>a_brakes = 1\nsim_instance = PointerMotionSim(a_brakes)\ncurrent_timestamp = time.monotonic_ns()\ncurrent_touch_pos = (50, 50)\nsim_instance.tick(current_timestamp, current_touch_pos)\n</code></pre> Source code in <code>src/pointer_brakes/_sim.py</code> <pre><code>def tick(self, timestamp: int, touch_pos: tuple[int, int] | None = None) -&gt; None:\n    \"\"\"Update the state of the PointerMotionSim\n\n    This method updates the simulation state of the PointerMotionSim instance. When\n    touch position is provided the pointer will be moved.  When the touch position,\n    inevitably, goes idle then the simulation will continue moving until the\n    pointer comes to rest due to braking.\n\n    Args:\n        timestamp (int): The timestamp at which the update occurs.\n        touch_pos (tuple[int, int] | None): The current touch position as a tuple\n            (x, y), or None if touch is idle.\n\n    Example usage:\n    ```python\n    a_brakes = 1\n    sim_instance = PointerMotionSim(a_brakes)\n    current_timestamp = time.monotonic_ns()\n    current_touch_pos = (50, 50)\n    sim_instance.tick(current_timestamp, current_touch_pos)\n    ```\n    \"\"\"\n    # if touch is idle and motion is stopped then do nothing\n    if not touch_pos and not self.velocity:\n        # ensure state is cleared to reflect idleness\n        if self._state.timestamp:\n            self.stop_motion()\n        return\n\n    # if touch is idle then update initial velocity\n    if not touch_pos:\n        self._v0 = self.velocity\n\n    # reject zero-time ticks\n    if self._state.timestamp == timestamp:\n        return\n\n    # update simulation state\n    self._last_state = self._state.copy()\n    self._state = EMPTY_STATE.copy()\n    self._state.timestamp = timestamp\n\n    # update touch data if present\n    self._state.touch_pos = touch_pos if touch_pos else None\n</code></pre>"}]}